/**
 * Marketing Cloud REST API
 * Marketing Cloud's REST API is our newest API. It supports multi-channel use cases, is much more lightweight and easy to use than our SOAP API, and is getting more comprehensive with every release.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: mc_sdk@salesforce.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */


const ApiError = require ('../Model/ApiError');
const CreateEmailDefinitionRequest = require ('../Model/CreateEmailDefinitionRequest');
const CreateSmsDefinitionRequest = require ('../Model/CreateSmsDefinitionRequest');
const DeleteQueuedMessagesForSendDefinitionResponse = require ('../Model/DeleteQueuedMessagesForSendDefinitionResponse');
const DeleteSendDefinitionResponse = require ('../Model/DeleteSendDefinitionResponse');
const GetDefinitionSendStatusForRecipientResponse = require ('../Model/GetDefinitionSendStatusForRecipientResponse');
const GetDefinitionsNotSentToRecipientsResponse = require ('../Model/GetDefinitionsNotSentToRecipientsResponse');
const GetEmailDefinitionsResponse = require ('../Model/GetEmailDefinitionsResponse');
const GetQueueMetricsForSendDefinitionResponse = require ('../Model/GetQueueMetricsForSendDefinitionResponse');
const GetSmsDefinitionsResponse = require ('../Model/GetSmsDefinitionsResponse');
const SendDefinitionToMultipleRecipientsResponse = require ('../Model/SendDefinitionToMultipleRecipientsResponse');
const SendDefinitionToSingleRecipientResponse = require ('../Model/SendDefinitionToSingleRecipientResponse');
const SendEmailToMultipleRecipientsRequest = require ('../Model/SendEmailToMultipleRecipientsRequest');
const SendEmailToSingleRecipientRequest = require ('../Model/SendEmailToSingleRecipientRequest');
const SendSmsToMultipleRecipientsRequest = require ('../Model/SendSmsToMultipleRecipientsRequest');
const SendSmsToSingleRecipientRequest = require ('../Model/SendSmsToSingleRecipientRequest');
const UpdateEmailDefinitionRequest = require ('../Model/UpdateEmailDefinitionRequest');
const UpdateSmsDefinitionRequest = require ('../Model/UpdateSmsDefinitionRequest');
const BaseApi = require('./BaseApi');

/**
* TransactionalMessaging service.
* @module Api/TransactionalMessagingApi
* @version 1.0.0
*/
module.exports = class TransactionalMessagingApi extends BaseApi {

    /**
    * Constructs a new TransactionalMessagingApi. 
    * @alias module:Api/TransactionalMessagingApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(authBaseUrl, clientId, clientSecret, accountId, scope) {
        super(authBaseUrl, clientId, clientSecret, accountId, scope);
    }



    /**
     * createEmailDefinition
     * Creates the definition for an email.
     * @param {module:Model/CreateEmailDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateEmailDefinitionRequest} and HTTP response
     */
    createEmailDefinitionWithHttpInfo(caller, body) {
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createEmailDefinition");
      }


      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * createEmailDefinition
     * Creates the definition for an email.
     * @param {module:Model/CreateEmailDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateEmailDefinitionRequest}
     */
    createEmailDefinition(body) {
      return this.createEmailDefinitionWithHttpInfo('createEmailDefinition', body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * createSmsDefinition
     * Creates the definition for an SMS.
     * @param {module:Model/CreateSmsDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateSmsDefinitionRequest} and HTTP response
     */
    createSmsDefinitionWithHttpInfo(caller, body) {
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling createSmsDefinition");
      }


      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * createSmsDefinition
     * Creates the definition for an SMS.
     * @param {module:Model/CreateSmsDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateSmsDefinitionRequest}
     */
    createSmsDefinition(body) {
      return this.createSmsDefinitionWithHttpInfo('createSmsDefinition', body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * deleteEmailDefinition
     * Deletes an email definition. You can&#39;t restore a deleted definition. The deleted definition is archived, and a delete location of the definition key is provided in the response for reference. You can reuse a deleted definition key because the information associated with it is copied to a new unique identifier.
     * @param {String} definitionKey Unique identifier of the definition to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/DeleteSendDefinitionResponse} and HTTP response
     */
    deleteEmailDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling deleteEmailDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/{definitionKey}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * deleteEmailDefinition
     * Deletes an email definition. You can&#39;t restore a deleted definition. The deleted definition is archived, and a delete location of the definition key is provided in the response for reference. You can reuse a deleted definition key because the information associated with it is copied to a new unique identifier.
     * @param {String} definitionKey Unique identifier of the definition to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/DeleteSendDefinitionResponse}
     */
    deleteEmailDefinition(definitionKey) {
      return this.deleteEmailDefinitionWithHttpInfo('deleteEmailDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * deleteQueuedMessagesForEmailDefinition
     * Deletes the queue for an email definition. The email definition must be in inactive status.
     * @param {String} definitionKey Unique identifier of the email definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/DeleteQueuedMessagesForSendDefinitionResponse} and HTTP response
     */
    deleteQueuedMessagesForEmailDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling deleteQueuedMessagesForEmailDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/{definitionKey}/queue', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * deleteQueuedMessagesForEmailDefinition
     * Deletes the queue for an email definition. The email definition must be in inactive status.
     * @param {String} definitionKey Unique identifier of the email definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/DeleteQueuedMessagesForSendDefinitionResponse}
     */
    deleteQueuedMessagesForEmailDefinition(definitionKey) {
      return this.deleteQueuedMessagesForEmailDefinitionWithHttpInfo('deleteQueuedMessagesForEmailDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * deleteQueuedMessagesForSmsDefinition
     * Deletes the queue for a SMS definition. The SMS definition must be in inactive status.
     * @param {String} definitionKey Unique identifier of the SMS definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/DeleteQueuedMessagesForSendDefinitionResponse} and HTTP response
     */
    deleteQueuedMessagesForSmsDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling deleteQueuedMessagesForSmsDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions/{definitionKey}/queue', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * deleteQueuedMessagesForSmsDefinition
     * Deletes the queue for a SMS definition. The SMS definition must be in inactive status.
     * @param {String} definitionKey Unique identifier of the SMS definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/DeleteQueuedMessagesForSendDefinitionResponse}
     */
    deleteQueuedMessagesForSmsDefinition(definitionKey) {
      return this.deleteQueuedMessagesForSmsDefinitionWithHttpInfo('deleteQueuedMessagesForSmsDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * deleteSmsDefinition
     * Deletes an sms definition. You can&#39;t restore a deleted definition. The deleted definition is archived, and a delete location of the definition key is provided in the response for reference. You can reuse a deleted definition key because the information associated with it is copied to a new unique identifier.
     * @param {String} definitionKey Unique identifier of the definition to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/DeleteSendDefinitionResponse} and HTTP response
     */
    deleteSmsDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling deleteSmsDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions/{definitionKey}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * deleteSmsDefinition
     * Deletes an sms definition. You can&#39;t restore a deleted definition. The deleted definition is archived, and a delete location of the definition key is provided in the response for reference. You can reuse a deleted definition key because the information associated with it is copied to a new unique identifier.
     * @param {String} definitionKey Unique identifier of the definition to delete
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/DeleteSendDefinitionResponse}
     */
    deleteSmsDefinition(definitionKey) {
      return this.deleteSmsDefinitionWithHttpInfo('deleteSmsDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getEmailDefinition
     * Gets email definition configuration details for a definition key.
     * @param {String} definitionKey Unique identifier of the definition to get
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateEmailDefinitionRequest} and HTTP response
     */
    getEmailDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling getEmailDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/{definitionKey}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getEmailDefinition
     * Gets email definition configuration details for a definition key.
     * @param {String} definitionKey Unique identifier of the definition to get
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateEmailDefinitionRequest}
     */
    getEmailDefinition(definitionKey) {
      return this.getEmailDefinitionWithHttpInfo('getEmailDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getEmailDefinitions
     * Gets a list of email definitions.
     * @param {Object} opts Optional parameters
     * @param {module:Model/String} opts.status Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq.
     * @param {Number} opts.pageSize Number of definitions, which are array elements, to return per paged response.
     * @param {Number} opts.page Page number to return.
     * @param {module:Model/String} opts.orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetEmailDefinitionsResponse} and HTTP response
     */
    getEmailDefinitionsWithHttpInfo(caller, opts) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'status': opts['status'],
        'pageSize': opts['pageSize'],
        'page': opts['page'],
        'orderBy': opts['orderBy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getEmailDefinitions
     * Gets a list of email definitions.
     * @param {Object} opts Optional parameters
     * @param {module:Model/String} opts.status Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq.
     * @param {Number} opts.pageSize Number of definitions, which are array elements, to return per paged response.
     * @param {Number} opts.page Page number to return.
     * @param {module:Model/String} opts.orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetEmailDefinitionsResponse}
     */
    getEmailDefinitions(opts) {
      return this.getEmailDefinitionsWithHttpInfo('getEmailDefinitions', opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getEmailSendStatusForRecipient
     * Gets the send status for a message. Because this route is rate-limited, use it for infrequent verification of a messageKey. To collect send status at scale, subscribe to transactional send events using the Event Notification Service.
     * @param {String} messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you don’t provide the message key for recipients, it’s generated in the response.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetDefinitionSendStatusForRecipientResponse} and HTTP response
     */
    getEmailSendStatusForRecipientWithHttpInfo(caller, messageKey) {
      let postBody = null;

      // verify the required parameter 'messageKey' is set
      if (messageKey === undefined || messageKey === null) {
        throw new Error("Missing the required parameter 'messageKey' when calling getEmailSendStatusForRecipient");
      }


      let pathParams = {
        'messageKey': messageKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/messages/{messageKey}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getEmailSendStatusForRecipient
     * Gets the send status for a message. Because this route is rate-limited, use it for infrequent verification of a messageKey. To collect send status at scale, subscribe to transactional send events using the Event Notification Service.
     * @param {String} messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you don’t provide the message key for recipients, it’s generated in the response.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetDefinitionSendStatusForRecipientResponse}
     */
    getEmailSendStatusForRecipient(messageKey) {
      return this.getEmailSendStatusForRecipientWithHttpInfo('getEmailSendStatusForRecipient', messageKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getEmailsNotSentToRecipients
     * Gets a paginated list of messages that were not sent, ordered from oldest to newest.
     * @param {String} type Only notSent is supported.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize Number of messageKeys (array elements) to return per response page.
     * @param {Number} opts.lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetDefinitionsNotSentToRecipientsResponse} and HTTP response
     */
    getEmailsNotSentToRecipientsWithHttpInfo(caller, type, opts) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'type' is set
      if (type === undefined || type === null) {
        throw new Error("Missing the required parameter 'type' when calling getEmailsNotSentToRecipients");
      }


      let pathParams = {
      };
      let queryParams = {
        'type': type,
        '$pageSize': opts['pageSize'],
        'lastEventId': opts['lastEventId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/messages/', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getEmailsNotSentToRecipients
     * Gets a paginated list of messages that were not sent, ordered from oldest to newest.
     * @param {String} type Only notSent is supported.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize Number of messageKeys (array elements) to return per response page.
     * @param {Number} opts.lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetDefinitionsNotSentToRecipientsResponse}
     */
    getEmailsNotSentToRecipients(type, opts) {
      return this.getEmailsNotSentToRecipientsWithHttpInfo('getEmailsNotSentToRecipients', type, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getQueueMetricsForEmailDefinition
     * Gets metrics for the messages of an email definition. Applies to messages that are accepted but not yet processed.
     * @param {String} definitionKey Unique identifier of the email definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetQueueMetricsForSendDefinitionResponse} and HTTP response
     */
    getQueueMetricsForEmailDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling getQueueMetricsForEmailDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/{definitionKey}/queue', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getQueueMetricsForEmailDefinition
     * Gets metrics for the messages of an email definition. Applies to messages that are accepted but not yet processed.
     * @param {String} definitionKey Unique identifier of the email definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetQueueMetricsForSendDefinitionResponse}
     */
    getQueueMetricsForEmailDefinition(definitionKey) {
      return this.getQueueMetricsForEmailDefinitionWithHttpInfo('getQueueMetricsForEmailDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getQueueMetricsForSmsDefinition
     * Gets metrics for the messages of a SMS definition. Applies to messages that are accepted but not yet processed.
     * @param {String} definitionKey Unique identifier of the SMS definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetQueueMetricsForSendDefinitionResponse} and HTTP response
     */
    getQueueMetricsForSmsDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling getQueueMetricsForSmsDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions/{definitionKey}/queue', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getQueueMetricsForSmsDefinition
     * Gets metrics for the messages of a SMS definition. Applies to messages that are accepted but not yet processed.
     * @param {String} definitionKey Unique identifier of the SMS definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetQueueMetricsForSendDefinitionResponse}
     */
    getQueueMetricsForSmsDefinition(definitionKey) {
      return this.getQueueMetricsForSmsDefinitionWithHttpInfo('getQueueMetricsForSmsDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getSMSsNotSentToRecipients
     * Gets a paginated list of messages that were not sent, ordered from oldest to newest.
     * @param {String} type Only notSent is supported.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize Number of messageKeys (array elements) to return per response page.
     * @param {Number} opts.lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetDefinitionsNotSentToRecipientsResponse} and HTTP response
     */
    getSMSsNotSentToRecipientsWithHttpInfo(caller, type, opts) {
      opts = opts || {};
      let postBody = null;

      // verify the required parameter 'type' is set
      if (type === undefined || type === null) {
        throw new Error("Missing the required parameter 'type' when calling getSMSsNotSentToRecipients");
      }


      let pathParams = {
      };
      let queryParams = {
        'type': type,
        '$pageSize': opts['pageSize'],
        'lastEventId': opts['lastEventId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/messages/', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getSMSsNotSentToRecipients
     * Gets a paginated list of messages that were not sent, ordered from oldest to newest.
     * @param {String} type Only notSent is supported.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.pageSize Number of messageKeys (array elements) to return per response page.
     * @param {Number} opts.lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetDefinitionsNotSentToRecipientsResponse}
     */
    getSMSsNotSentToRecipients(type, opts) {
      return this.getSMSsNotSentToRecipientsWithHttpInfo('getSMSsNotSentToRecipients', type, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getSmsDefinition
     * Gets SMS definition configuration details for a definition key.
     * @param {String} definitionKey Unique identifier of the definition to get
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateSmsDefinitionRequest} and HTTP response
     */
    getSmsDefinitionWithHttpInfo(caller, definitionKey) {
      let postBody = null;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling getSmsDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions/{definitionKey}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getSmsDefinition
     * Gets SMS definition configuration details for a definition key.
     * @param {String} definitionKey Unique identifier of the definition to get
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateSmsDefinitionRequest}
     */
    getSmsDefinition(definitionKey) {
      return this.getSmsDefinitionWithHttpInfo('getSmsDefinition', definitionKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getSmsDefinitions
     * Gets a list of SMS definitions.
     * @param {Object} opts Optional parameters
     * @param {module:Model/String} opts.status Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq.
     * @param {Number} opts.pageSize Number of definitions, which are array elements, to return per paged response.
     * @param {Number} opts.page Page number to return.
     * @param {module:Model/String} opts.orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetSmsDefinitionsResponse} and HTTP response
     */
    getSmsDefinitionsWithHttpInfo(caller, opts) {
      opts = opts || {};
      let postBody = null;


      let pathParams = {
      };
      let queryParams = {
        'status': opts['status'],
        'pageSize': opts['pageSize'],
        'page': opts['page'],
        'orderBy': opts['orderBy']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getSmsDefinitions
     * Gets a list of SMS definitions.
     * @param {Object} opts Optional parameters
     * @param {module:Model/String} opts.status Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq.
     * @param {Number} opts.pageSize Number of definitions, which are array elements, to return per paged response.
     * @param {Number} opts.page Page number to return.
     * @param {module:Model/String} opts.orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetSmsDefinitionsResponse}
     */
    getSmsDefinitions(opts) {
      return this.getSmsDefinitionsWithHttpInfo('getSmsDefinitions', opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * getSmsSendStatusForRecipient
     * Gets the send status for a message. Because this route is rate-limited, use it for infrequent verification of a messageKey. To collect send status at scale, subscribe to transactional send events using the Event Notification Service.
     * @param {String} messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you don’t provide the message key for recipients, it’s generated in the response.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/GetDefinitionSendStatusForRecipientResponse} and HTTP response
     */
    getSmsSendStatusForRecipientWithHttpInfo(caller, messageKey) {
      let postBody = null;

      // verify the required parameter 'messageKey' is set
      if (messageKey === undefined || messageKey === null) {
        throw new Error("Missing the required parameter 'messageKey' when calling getSmsSendStatusForRecipient");
      }


      let pathParams = {
        'messageKey': messageKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/messages/{messageKey}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * getSmsSendStatusForRecipient
     * Gets the send status for a message. Because this route is rate-limited, use it for infrequent verification of a messageKey. To collect send status at scale, subscribe to transactional send events using the Event Notification Service.
     * @param {String} messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you don’t provide the message key for recipients, it’s generated in the response.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/GetDefinitionSendStatusForRecipientResponse}
     */
    getSmsSendStatusForRecipient(messageKey) {
      return this.getSmsSendStatusForRecipientWithHttpInfo('getSmsSendStatusForRecipient', messageKey)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * partiallyUpdateEmailDefinition
     * Updates a specific email definition.
     * @param {String} definitionKey Unique identifier of the definition.
     * @param {module:Model/UpdateEmailDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateEmailDefinitionRequest} and HTTP response
     */
    partiallyUpdateEmailDefinitionWithHttpInfo(caller, definitionKey, body) {
      let postBody = body;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling partiallyUpdateEmailDefinition");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling partiallyUpdateEmailDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/definitions/{definitionKey}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * partiallyUpdateEmailDefinition
     * Updates a specific email definition.
     * @param {String} definitionKey Unique identifier of the definition.
     * @param {module:Model/UpdateEmailDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateEmailDefinitionRequest}
     */
    partiallyUpdateEmailDefinition(definitionKey, body) {
      return this.partiallyUpdateEmailDefinitionWithHttpInfo('partiallyUpdateEmailDefinition', definitionKey, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * partiallyUpdateSmsDefinition
     * Updates a specific SMS definition.
     * @param {String} definitionKey Unique identifier of the definition.
     * @param {module:Model/UpdateSmsDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/CreateSmsDefinitionRequest} and HTTP response
     */
    partiallyUpdateSmsDefinitionWithHttpInfo(caller, definitionKey, body) {
      let postBody = body;

      // verify the required parameter 'definitionKey' is set
      if (definitionKey === undefined || definitionKey === null) {
        throw new Error("Missing the required parameter 'definitionKey' when calling partiallyUpdateSmsDefinition");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling partiallyUpdateSmsDefinition");
      }


      let pathParams = {
        'definitionKey': definitionKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/definitions/{definitionKey}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * partiallyUpdateSmsDefinition
     * Updates a specific SMS definition.
     * @param {String} definitionKey Unique identifier of the definition.
     * @param {module:Model/UpdateSmsDefinitionRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/CreateSmsDefinitionRequest}
     */
    partiallyUpdateSmsDefinition(definitionKey, body) {
      return this.partiallyUpdateSmsDefinitionWithHttpInfo('partiallyUpdateSmsDefinition', definitionKey, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * sendEmailToMultipleRecipients
     * Sends a message to multiple recipients using an email definition. You can provide a messageKey in the request; otherwise, the messageKey is automatically generated in the response.
     * @param {module:Model/SendEmailToMultipleRecipientsRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/SendDefinitionToMultipleRecipientsResponse} and HTTP response
     */
    sendEmailToMultipleRecipientsWithHttpInfo(caller, body) {
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling sendEmailToMultipleRecipients");
      }


      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/messages/', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * sendEmailToMultipleRecipients
     * Sends a message to multiple recipients using an email definition. You can provide a messageKey in the request; otherwise, the messageKey is automatically generated in the response.
     * @param {module:Model/SendEmailToMultipleRecipientsRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/SendDefinitionToMultipleRecipientsResponse}
     */
    sendEmailToMultipleRecipients(body) {
      return this.sendEmailToMultipleRecipientsWithHttpInfo('sendEmailToMultipleRecipients', body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * sendEmailToSingleRecipient
     * Sends a message to a single recipient via an email definition using a messageKey path parameter.
     * @param {String} messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected.
     * @param {module:Model/SendEmailToSingleRecipientRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/SendDefinitionToSingleRecipientResponse} and HTTP response
     */
    sendEmailToSingleRecipientWithHttpInfo(caller, messageKey, body) {
      let postBody = body;

      // verify the required parameter 'messageKey' is set
      if (messageKey === undefined || messageKey === null) {
        throw new Error("Missing the required parameter 'messageKey' when calling sendEmailToSingleRecipient");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling sendEmailToSingleRecipient");
      }


      let pathParams = {
        'messageKey': messageKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/email/messages/{messageKey}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * sendEmailToSingleRecipient
     * Sends a message to a single recipient via an email definition using a messageKey path parameter.
     * @param {String} messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected.
     * @param {module:Model/SendEmailToSingleRecipientRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/SendDefinitionToSingleRecipientResponse}
     */
    sendEmailToSingleRecipient(messageKey, body) {
      return this.sendEmailToSingleRecipientWithHttpInfo('sendEmailToSingleRecipient', messageKey, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * sendSmsToMultipleRecipients
     * Sends a message to multiple recipients using an email definition. You can provide a messageKey in the request; otherwise, the messageKey is automatically generated in the response.
     * @param {module:Model/SendSmsToMultipleRecipientsRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/SendDefinitionToMultipleRecipientsResponse} and HTTP response
     */
    sendSmsToMultipleRecipientsWithHttpInfo(caller, body) {
      let postBody = body;

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling sendSmsToMultipleRecipients");
      }


      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/messages/', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * sendSmsToMultipleRecipients
     * Sends a message to multiple recipients using an email definition. You can provide a messageKey in the request; otherwise, the messageKey is automatically generated in the response.
     * @param {module:Model/SendSmsToMultipleRecipientsRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/SendDefinitionToMultipleRecipientsResponse}
     */
    sendSmsToMultipleRecipients(body) {
      return this.sendSmsToMultipleRecipientsWithHttpInfo('sendSmsToMultipleRecipients', body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * sendSmsToSingleRecipient
     * Sends a message to a single recipient via a SMS definition using a messageKey path parameter.
     * @param {String} messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected.
     * @param {module:Model/SendSmsToSingleRecipientRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:Model/SendDefinitionToSingleRecipientResponse} and HTTP response
     */
    sendSmsToSingleRecipientWithHttpInfo(caller, messageKey, body) {
      let postBody = body;

      // verify the required parameter 'messageKey' is set
      if (messageKey === undefined || messageKey === null) {
        throw new Error("Missing the required parameter 'messageKey' when calling sendSmsToSingleRecipient");
      }

      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling sendSmsToSingleRecipient");
      }


      let pathParams = {
        'messageKey': messageKey
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authName = '';
      let contentTypes = [];
      let accepts = [];
      let returnType = Object;

      return this.apiClient.callApi(
        '/messaging/v1/sms/messages/{messageKey}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authName, contentTypes, accepts, returnType, caller
      );
    }

    /**
     * sendSmsToSingleRecipient
     * Sends a message to a single recipient via a SMS definition using a messageKey path parameter.
     * @param {String} messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected.
     * @param {module:Model/SendSmsToSingleRecipientRequest} body JSON Parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:Model/SendDefinitionToSingleRecipientResponse}
     */
    sendSmsToSingleRecipient(messageKey, body) {
      return this.sendSmsToSingleRecipientWithHttpInfo('sendSmsToSingleRecipient', messageKey, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
